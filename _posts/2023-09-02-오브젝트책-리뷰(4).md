---
title: 오브젝트 책 리뷰 - (4) 객체지향 5대원칙(SOLID)
date: 2023-09-02 21:50:00 +0900
categories: [Books, 오브젝트]
tags: [책 리뷰] # TAG names should always be lowercase
toc: true
---

## 서론
이번 글은 객체지향에서 유명한 원칙인 SOLID에 대해 정리한다. 오브젝트와 클린 아키텍처 책에서 읽은 내용들을 같이 담아보려 노력했다. 

## SRP(단일책임원칙)
> 하나의 모듈(~= 소스 파일)은 하나의, 오직 하나의 액터(요구사항 변경을 원하는 사용자)에 대해서만 책임져야 한다.

- 응집도가 높으면 단일 액터를 책임지는 코드를 함께 묶어줄 수 있다. 응집도가 낮다는 것의 의미가 관련된 상태와 행동이 여기저기에 분리되어 있다는 의미고 따라서 하나의 변경에 대해 여러 모듈의 수정이 필요하기 때문이다.

## OCP(개방폐쇄원칙)
> 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

- 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계는 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조
- 개방-폐쇄 원칙의 핵심은 `추상화에 의존하는 것`임
- [의존성(결합도) 관리하기](https://hymn-fly.github.io/blogs/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%B1%85-%EB%A6%AC%EB%B7%B0(2)/#%EC%9D%98%EC%A1%B4%EC%84%B1%EA%B2%B0%ED%95%A9%EB%8F%84-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0) 에서 본 것처럼 `Movie`가 `DiscountPolicy`라는 추상화에 의존하는 것이 개방폐쇄원칙을 지킬 수 있도록 해주는 것임

### 생성과 사용을 분리

- 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임(객체의 생성, 객체의 사용)을 서로 다른 객체로 분리해야 함
- `Movie`는 `DiscountPolicy`를 **사용**하고, `Movie`에게 `DiscountPolicy` 타입의 객체를 **생성**해서 넘겨주는 것은 클라이언트
    
    ```java
    public class Client {
      public Money getAvatarFee() {
    	  Movie avatar = new Movie("아바타", Duration.ofMinutes(120),
                Money.wons(10000), new AmountDiscountPolicy(..));
    	  return avatar.getFee();
    	}
    }
    ```
    
- 사용을 하는 입장(`Movie`)에서는 추상화(`DiscountPolicy`)에 의존하여 컨텍스트에 독립적으로 사용을 하고 클라이언트(`Movie`를 사용하는 클라이언트)가 컨텍스트(`AmountDiscountPolicy`, `PercentDiscountPolicy` , …)에 대한 결정권을 가지고 의존성 해결을 해줌

## LSP (리스코프 치환 원칙)
- 오브젝트 책에서는 리스코프 치환 원칙을 `행동 호환성` 이라는 한 단어로 표현한다. 즉, `클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다`는 것이다.
- 자식 클래스가 클라이언트의 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다. 따라서 **리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제조건이다**
 
 리스코프 치환 원칙을 따르지 않는 예로 펭귄과 새의 관계가 나오게 되는데 아래 예시 코드를 보자.
```java
  public interface Bird {
    public void fly() { ... }
    ...
  }

  public class Penguin extends Bird {
    ...
    @Override
    public void fly() {}
  }

  public void flyBird(Bird bird) {
    // 인자로 전달된 모든 bird는 날 수 있어야 한다
    bird.fly();
  }
```
위 예시 코드에서 `Penguin`은 클라이언트에게 `Bird`와 행동 호환이 되지 않기에 리스코프 치환 원칙을 충족시키지 않는다.(<=> 행동호환성 충족 x)

## ISP (인터페이스 분리 원칙)
- 인터페이스는 클라이언트의 기대에 맞게(=사용하려는 의도에 따라) 분리되어야 한다는 것임
  - 위 예시에서 `Penguin`은 날지 못하는 새이기에, 날 수 있는 새를 위한 인터페이스(`FlyingBird`)가 필요하다. (클라이언트에서 사용하려는 의도가 다를 때는 다른 인터페이스를 이용해야 하는 것)
  ![Penguin-Bird](/assets/images/2023-09-02/class-diagram2.png)_Interface 분리한 클래스 다이어그램_

  - 하나의 클라이언트가 오직 fly 메시지만 전송하기를 원한다면 이 클라이언트에게는 fly 메시지만을 노출하는 인터페이스가 필요한 것
  - 다른 클라이언트가 오직 walk 메시지만 전송하기를 원한다면 이 클라이언트에게는 walk 메시지만을 노출하는 인터페이스가 필요한 것

## DIP(의존성 역전 원칙)

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
    - 위의 예시에서 `Movie`가 `AmountDiscountPolicy`라는 구체적인 하위 수준 모듈에 의존한다면 할인정책을 바꾼다고 할때(=구현이 바뀌면) 변경이 전파됨
    - 따라서 `Movie`는 `DiscountPolicy`라는 추상화에 의존해야 하고 `AmountDiscountPolicy`도 `DiscountPolicy`에 의존해야 함(상속)
    
    ![Movie와 AmountDiscountPolicy 모두 DiscountPolicy라는 추상화에 의존함!](/assets/images/2023-09-02/class-diagram.png)_Movie와 AmountDiscountPolicy 모두 DiscountPolicy라는 추상화에 의존함!_
    
2. 추상화(`DiscountPolicy`)는 구체적인 사항(`AmountDiscountPolicy`, `PercentDiscountPolicy`)에 의존해서는 안 된다. 구체적인 사항이 추상화에 의존해야 한다.

> 좋은 객체지향 설계의 증명이 바로 이와 같은 의존성의 역전이다. 프로그램의 의존성이 역전돼 있다면, 이것은 객체지향 설계를 갖는 것이다. 의존성이 역전돼 있지 않다면, 절차적 설계를 갖는 것이다. 
이 원칙은 또한 변경에 탄력적인 코드를 작성하는 데 있어 결정적으로 중요하다. 추상화와 구체적인 사항이 서로 고립돼 있기 때문에 이 코드는 유지보수하기가 훨씬 쉽다 — 로버트 마틴
> 

### 의존성 역전 원칙과 패키지

![인터페이스가 서버 모듈 쪽에 위치하는 전통적인 모듈 구조](/assets/images/2023-09-02/package-structure1.png)_인터페이스가 서버 모듈 쪽에 위치하는 전통적인 모듈 구조_

![인터페이스의 소유권을 클라이언트로 역전시킨 객체지향적인 모듈 구조](/assets/images/2023-09-02/package-structure2.png)_인터페이스의 소유권을 클라이언트로 역전시킨 객체지향적인 모듈 구조_

- `Movie`와 `DiscountPolicy`를 하나의 패키지로 모음으로써 `Movie`를 특정한 컨텍스트(할인정책의 종류)로부터 완벽하게 독립 시킬 수 있게 되고 이는 상위 수준의 협력 흐름을 재사용 하기 쉽게 만들어줌

## 유연성에 대한 조언

  `유연한 설계`라는 말의 이면에는 `복잡한 설계`라는 의미가 숨어있기에 아직 일어나지 않은 변경에 대한 불안감으로 불필요하게 복잡한 설계를 하지 않아야 한다(`불필요한 유연성은 불필요한 복잡성을 낳는다`)

  만약 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라. 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.
